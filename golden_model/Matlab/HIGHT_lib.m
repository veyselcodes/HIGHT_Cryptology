%%%%
%% HIGHT_lib
%%%%
%%%%
%% The function transform an message (X) into a state (state) to be processed by the other functions.
%% If the message is binary coded, m=0.
%% If the message is coded in hexadecimal, m=1
%%%%
clear;clc;
function state=create_state(X, m)
  state=[];
  if m<=0
    for i=1:8:(length(X)-7)
      state=[bin2dec(X(i:i+7)) state];
    end
  else
    j=0;
    for i=1:2:length(X)-1
      j++;
      state=[hex2dec(X(i:i+1)) state];
    end
  end
end

%%%%
%% Keychedule
%%%%

function wk=whiteningKey(K) 
%% create the whitening key that is used before the first round and after the last round
  for i=1:8
    if i<=4
      wk(i)=K(i+12);
    else
      wk(i)=K(i-4);
    end
  end
end

function cst=constantGen()
%% Generate constants used for the round
  cst='0101101';
  for i=1:127
    cst(7+i)=dec2bin(bitxor(bin2dec(cst(i+3)), bin2dec(cst(i))), 1);
  end
end

function c=extract_const(cst, i)
%% Extract the correct constant for the round i from the vector cst generated by the function constantGen
  c='';
  for j=i:i+6
    c=[cst(j+1) c];
  end
end

function sk=subkey(K, cst)
%% Generated the subkey used during the round
  for i=0:7
    for j=0:7
      c=extract_const(cst, 16*i+j);
      sk(16*i+j+1)=mod(K(mod(j-i, 8)+1)+ bin2dec(c), 256);
      c=extract_const(cst, 16*i+j+8);
      sk(16*i+j+9)=mod(K(mod(j-i, 8)+9)+ bin2dec(c), 256);
    end
  end
end

%%%%
%%  Initial transformations
%%%%
function x=initialTransformation(P, wk)

  x(1)=mod(P(1)+wk(1), 256);
  x(2)=P(2);
  x(3)=bitxor(P(3), wk(2));
  x(4)=P(4);
  x(5)=mod(P(5)+wk(3), 256);
  x(6)=P(6);
  x(7)=bitxor(P(7), wk(4));
  x(8)=P(8);
end

function x=initialTransformation_d(P, wk)
  x(2)=mod(P(1)-wk(5), 256);
  x(3)=P(2);
  x(4)=bitxor(P(3), wk(6));
  x(5)=P(4);
  x(6)=mod(P(5)-wk(7), 256);
  x(7)=P(6);
  x(8)=bitxor(P(7), wk(8));
  x(1)=P(8);
end

%%%%
%%  round
%%%%

function res=rotl(bin, d) %% Left rotation of d bits
  if d>1
    res=rotl([bin(2:end) bin(1)], d-1);
  else
    res=[bin(2:end) bin(1)];
  end
end

function x=f0(s) %% Function f0 of the round
  bin=dec2bin(s,8);
  x=bitxor(bitxor(bin2dec(rotl(bin,1)), bin2dec(rotl(bin,2))), bin2dec(rotl(bin,7)));
end

function x=f1(s) %% Function f1 of the round
  bin=dec2bin(s,8);
  x=bitxor(bitxor(bin2dec(rotl(bin,3)), bin2dec(rotl(bin,4))), bin2dec(rotl(bin,6)));
end

function x=Round(state, sk, i) %% Encryption
  x(1)=bitxor(state(8), mod(f0(state(7))+sk(4*i+4), 256));
  x(2)=state(1);
  x(3)=mod(state(2)+bitxor(f1(state(1)),sk(4*i+3)), 256);
  x(4)=state(3);
  x(5)=bitxor(state(4), mod(f0(state(3))+sk(4*i+2), 256));
  x(6)=state(5);
  x(7)=mod(state(6)+bitxor(f1(state(5)),sk(4*i+1)), 256);
  x(8)=state(7);
end

function x=Round_d(state, sk, i) %% Decryption
  sk_3=sk(4*i+4);
  x(8)=bitxor(state(1), mod(f0(state(8))+sk(4*i+4), 256));
  x(1)=state(2);
  sk_0=sk(4*i+1);
  x(2)=mod(state(3)-bitxor(f1(state(2)),sk(4*i+1)), 256);
  x(3)=state(4);
  sk_1=sk(4*i+2);
  x(4)=bitxor(state(5), mod(f0(state(4))+sk(4*i+2), 256));
  x(5)=state(6);
  sk_2=sk(4*i+3);
  x(6)=mod(state(7)-bitxor(f1(state(6)),sk(4*i+3)), 256);
  x(7)=state(8);
end

%%%%
%%  Final transformations
%%%%
function c=FinalTransformation(x, wk) %% Encryption
  c(1)=mod(x(2)+wk(5), 256);
  c(2)=x(3);
  c(3)=bitxor(x(4), wk(6));
  c(4)=x(5);
  c(5)=mod(x(6)+wk(7), 256);
  c(6)=x(7);
  c(7)=bitxor(x(8), wk(8));
  c(8)=x(1);
end

function c=FinalTransformation_d(x, wk) %% Decryption
  c(1)=mod(x(1)-wk(1), 256);
  c(2)=x(2);
  c(3)=bitxor(x(3), wk(2));
  c(4)=x(4);
  c(5)=mod(x(5)-wk(3), 256);
  c(6)=x(6);
  c(7)=bitxor(x(7), wk(4));
  c(8)=x(8);
end

%%%%
%%  Cipher algorithm
%%%%

function C=Hight_enc(m, k) %% Encryption
  %% Initialization
  state_m=create_state(m, 1)
  state_k=create_state(k, 1);
  wk=whiteningKey(state_k)
  cst=constantGen();
  sk=subkey(state_k, cst)
  state_m=initialTransformation(state_m, wk);
  %% Rounds
  for i=0:31
    state_m=Round(state_m, sk, i);
  end
  %% Final transformation
  C_tmp=FinalTransformation(state_m, wk);
  %% reformat cipher
  C_tmp=dec2hex(C_tmp);
  C='';
  for i=1:length(C_tmp)
    C=[C_tmp(i,:) C];
  end
end

function M=Hight_dec(C, k) %% Decryption
  %% Initialization
  state_m=create_state(C, 1)
  state_k=create_state(k, 1);
  wk=whiteningKey(state_k);
  cst=constantGen();
  sk=subkey(state_k, cst);
  state_m=initialTransformation_d(state_m, wk)
  %% Rounds
  for i=0:31
    31-i
    state_m=Round_d(state_m, sk, 31-i)
  end
  %% Final transformation
  M_tmp=FinalTransformation_d(state_m, wk)
  %% reformat message
  M_tmp=dec2hex(M_tmp);
  M='';
  for i=1:length(M_tmp)
    M=[M_tmp(i,:) M];
  end
end
